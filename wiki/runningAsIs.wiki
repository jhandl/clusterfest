#summary How to implement and run a clusterfest basic installation

This section takes the terminology from [understanding understanding clusterfest]

==Steps to have a running installation==
You must:

 * server-side:
    * configure the server (tell it where the nodes are and what modules to use)
    * run the server (start clusterfest and its web server)
    * Use a webbrowser to access the frontend
 * node-side:
    * add clustering code (add code that will enable the RPC listener on the node)
    * run the nodes 

==Configuring the server==

Configuration of the server is done in the {{{clustering.properties}}} config file. This file imports defaults from {{{clustering.properties.defaults}}} file that can be found inside the distribution jar.

Here you can config:

 * {{{clustering.nodes}}}: the list of nodes in the form address:port or address:port:installDir
 * {{{clustering.modules}}}: the list of modules in the form moduleName:moduleClass. The module class must be a subclass of {{{NodeContainerModule}}} and have an empty constructor.

And extra module configuration can be added here

==Running the server==

Running the server means executing the {{{main}}} method in {{{com.flaptor.clustering.HTTPClusteringServer}}} with the port as a parameter

a {{{start.sh}}} is provided that starts clusterfest in port 47050

also there is {{{status.sh}}} (tells you if it is running) and {{{stop.sh}}} (kills the server)

then check on your web browser
{{{
http://localhost:47050/clustering
}}}

==Adding clustering code to the node==

Somewhere in your node code you must create a {{{ClusterableServer}}} specifying a port and a node type (String)

{{{
ClusterableServer clusterableServer = new ClusterableServer(port , clusteringNodeType);
}}}

Then add module servers. Most modules will give you a helper method

{{{
Monitor.addMonitorServer(clusterableServer, new AbstractMonitoreable() {...implement methods here...});
Controller.addControllerServer(cclusterableServer, new ControllableImplementation());
}}}

Otherwise you have to provide a context (String) and a handler (implementation of the module interface wrapped by {{{XmlrpcSerialization}}} - see [addingAModule adding a module])

{{{
clusterableServer.addModuleServer("controllable", XmlrpcSerialization.handler(new ControllableImplementation()));
}}}