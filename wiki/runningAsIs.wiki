#summary How to implement and run a clusterfest basic installation

This section takes the terminology from [understanding understanding clusterfest]

==Steps to have a running installation==
You must:

 * server-side:
    * configure the server (tell it where the nodes are and what modules to use)
    * run the server (start clusterfest and its web server)
    * Use a webbrowser to access the frontend
 * node-side:
    * add clustering code (add code that will enable the RPC listener on the node)
    * run the nodes 

==Configuring the server==

Configuration of the server is done in the {{{clustering.properties}}} config file. This file imports defaults from {{{clustering.properties.defaults}}} file that can be found inside the distribution jar.

Here you can config:

 * {{{clustering.nodes}}}: the list of nodes in the form address:port or address:port:installDir
 * {{{clustering.modules}}}: the list of modules in the form moduleName:moduleClass. The module class must be a subclass of {{{NodeContainerModule}}} and have an empty constructor.

Any extra module configuration can be added here.

==Running the server==

Running the server means executing the {{{main}}} method in {{{com.flaptor.clustering.HTTPClusteringServer}}} with the port as a parameter

A {{{start.sh}}} is provided that starts clusterfest in port 47050

Also there is {{{status.sh}}} (tells you if it is running) and {{{stop.sh}}} (kills the server)

Then check on your web browser
{{{
http://localhost:47050/clustering
}}}

==Adding clustering code to the node==

Somewhere in your node code you must create a {{{ClusterableServer}}} specifying a port and a node type. The node type is a String that allows for further node discrimination, for example for identification in the node list home page (see [http://opensource.flaptor.com/clusterfest/screenshots.html screenshot]), or for enabling different behaviors within a module.

{{{
ClusterableServer clusterableServer = new ClusterableServer(port, "myNodeType");
}}}

Then add module servers. Most modules will give you a helper method.

{{{
Monitor.addMonitorServer(clusterableServer, new AbstractMonitoreable() {...implement methods here...});
Controller.addControllerServer(clusterableServer, new ControllableImplementation());
}}}

Otherwise you have to provide a context (String) and a handler (implementation of the module interface wrapped by {{{XmlrpcSerialization}}} - see [addingAModule adding a module]).

{{{
clusterableServer.addModuleServer("controllable", XmlrpcSerialization.handler(new ControllableImplementation()));
}}}